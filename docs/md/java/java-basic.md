# Java 基础 - 基本语法

> 万丈高楼平地起，本文介绍了 Java 的应知应会，是接下来学习的基础。@ice



## 1. 基本类型
<br>

|   类型    | 存储空间 |        取值范围        |                备注                |
| :-------: | :------: | :--------------------: | :--------------------------------: |
|  `byte`   |   8 位   |    $-128 \sim 127$     |                 —                  |
|  `short`  |  16 位   |  $-32768 \sim 32767$   |                 —                  |
|   `int`   |  32 位   | $-2^{31}\sim 2^{31}-1$ |              默认整型              |
|  `long`   |  64 位   | $-2^{63}\sim 2^{63}-1$ |          后缀 `l` 或 `L`           |
|  `float`  |  32 位   |           —            |          后缀 `f` 或 `F`           |
| `double`  |  64 位   |           —            |    默认浮点型，后缀 `d` 或 `D`     |
|  `char`   |  16 位   |     $0 \sim 65535$     | 注意转义字符，八进制和十六进制表示 |
| `boolean` |   1 位   |    `true`，`false`     |       不能与其他类型强制转换       |

:::tip

基本类型可以相互转换，包含隐式转换和显式转换，如下所示基本类型隐式转换规则，显示转换只需要沿着箭头反过来即可。

```
低  ------------------------------------>  高

byte,short,char—> int —> long—> float —> double
```

:::



> Java 整型计算时会全部转换成 `int` 型计算，浮点型会转换成 `double` 型计算。



## 2. 变量与常量

- 变量的声明

```java
类型 变量名 = 值;
```

- 常量的声明

```java
final 类型名 变量名 = 值;
```

:::warning

常局部变量声明时必须赋初值，类常成员可以不用赋初值，但是 JVM 会赋默认值。

:::

## 3. 运算符

- 算数运算：`+`、`-`、`*`、`/`、`%`
- 自增自减运算：`++`、`--`
- 关系运算符：`>`、`>=`、`==`、`!=`、`<=`、`<`
- 位运算符：`&`、`|`、`^`、`~`、`<<`、`>>`、`>>>`
- 逻辑运算符：`&&`、`||`、`!`
- 赋值运算符：`=`、`+=`、`-=`、`*=`、`/=`、`%=`、`<<=`、`>>=`、`&=`、`|=`、`^=`
- 条件运算符：`expression ? value_if_true : value_if_false`
- `instanceof` 运算符：`( Object reference variable ) instanceof  (class/interface type)`

:::tip

不用特别纠结运算符的优先级，没有什么不是一个括号不能解决的，如果是，那就两个。

:::

## 4. 数组

- 数组的声明

```java
dataType[] ary;
```

- 数组的初始化

1. 静态初始化：在声明数组时直接赋值数组元素

```
dataType[] ary = {e1,e2,...,en}; // 只能用在声明数组的同时赋值
```

2. 默认初始化：使用数组元素类型的默认值给元素赋值

```java
ary = new dataType[n];
```

> `n` 为数组长度，元素的值根据 `dataType` 的类型来确定，整型是 `0`，浮点型是 `0.0`，布尔型是 `false`，字符型是 `\u0000`， 引用类型是 `null`。

3. 动态初始化：分别给元素赋值

```java
ary[0] = e1;
ary[1] = e2;
ary[2] = e3;
```

:::tip

- 数组是一种**引用类型**，可以通过中括号实现下标访问，**下标索引从 `0` 开始**。
- **数组的内存空间是连续的，其长度不可更改**。
- 数组具有属性 `length`，可以返回数组的长度（元素个数）。
- JDK 提供了数组的辅助类 `Arrays`，实现了一些实用的功能。
- Java 支持多维数组，其实就是数组的数组，几维数组就有几个中括号（如二维数组 `int[][] matrix;`）。

:::

## 5. 字符串

> 这里仅简单介绍字符串的基础内容，详细内容见 `String` 的源码解析。

字符串是使用双引号引起来的一组字符序列。

`String` 被声明为 `final`，因此它不可被继承，**创建之后不可改变**。

内部使用 `char` 数组存储数据，该数组被声明为 `final`，这意味着 `value` 数组初始化之后就不能再引用其它数组。并且 ` String` 内部没有改变 `value` 数组的方法，因此可以保证 `String` 不可变。

```java
String s = "this is a String";
String s1 = new String(s);
String s2 = new String("this is a String");
```

## 6. 控制结构

### 6.1 条件控制语句

- `if` 语句

```java
if (condition == true) {
    statement
}
```

- `if` - `else` 语句

```java
if (condition == true) {
    statement1
} else {
    statement2
}
```

- 嵌套 `if` 语句

```java
if (condition1 == true) {
    statement1
} else if (condition1 == true) {
    statement2
} else {
    statement3
}
```

- `switch` 语句

```java
switch(expression){
    case value1:
        // do something
        break;
    case value2:
        // do something
        break;
    default:
        // do something
}
```

:::tip

- expression 只能是整型， JDK 1.7 之后也允许字符串型。
- 每个 case 语句结束必须使用 `break` 语句跳出，否则仍然会按照书写顺序向下执行。

:::

### 6.2 循环控制语句

- `while` 语句

```java
while (condition){
    statement
}
```

- `do-while` 语句

```java
do {
    statement
} while (condition);
```

> 注意，分号不能省。

- `for` 语句

```java
for (init-statement; condition; expression) {
    statement
}
```

- `for-each` 语句

```java
for (ElementType e: ArrayLike) {
    // do something with e
}
```

> 不建议在这种循环中修改元素，如果想强制避免修改，可以给 `ElementType` 前加上 `final` 关键字。

### 6.3 跳转语句

- `break` 语句：用于在循环语句中跳出最近的一层循环体
- `continue` 语句：跳过本次迭代，继续本次循环的下一次迭代

> 跳出多层循环需要借助标签机制，`break 标签名` 即可跳出标签所指向的循环。

## 7. 函数

```java
[修饰符] [static] [final] 返回值类型 函数名(参数列表){
    // 函数体
}
```

> - 没有返回值时，返回值类型是 `void。`
> - Java 中函数不能有默认值参数。
> - 最后一个形参可以是不定长参数，如 `int... ary`，使用时可将其当做数组使用

:::tip 函数重载

- Java 中函数允许重载，根据函数签名（函数名 + 参数列表）来区分不同的函数。
- 不能通过返回值来确定函数重载。

:::

## 8. 面向对象

### 8.1 类

```java
// 一般类
class A {
    // 属性
    // 方法
}

// 抽象类
abstract class B {
    // 属性
    // 方法
    // 至少一个抽象方法
    abstract void func();
}
```

:::tip

- 抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。

- **抽象类不能被实例化**，需要继承抽象类才能实例化其子类。
- Java 中使用 `extends` 关键字表示继承关系，且只允许**单继承**。

:::

### 8.2 访问权限

| 访问修饰符  | 类内 | 包内 | 子类 | 公开 |
| :---------: | :--: | :--: | :--: | :--: |
|  `public`   |  √   |  √   |  √   |  √   |
| `protected` |  √   |      |  √   |      |
| 默认不写时  |  √   |  √   |      |      |
|  `private`  |  √   |      |      |      |

### 8.3 接口

接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。

从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。

接口的成员(字段 + 方法)默认都是 public 的，并且不允许定义为 `private` 或者 `protected`。

接口的字段默认都是 `static` 和 `final` 的。

:::tip

- 类使用 `implements` 关键字来实现接口。
- 从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。
- 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。

:::

### 8.4 重写与重载

#### 8.4.1 重写（Override）

存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。

为了满足里式替换原则，重写有有以下两个限制：

- **子类方法的访问权限必须大于等于父类方法**
- **子类方法的返回类型必须是父类方法返回类型或为其子类型**

使用 `@Override` 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。

#### 8.4.2 重载（Overload）

存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。

应该注意的是，返回值不同，其它都相同不算是重载。

