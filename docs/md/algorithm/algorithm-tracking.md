#  算法思想 - 回溯算法

回溯法思路的简单描述是：把问题的解空间转化成了图或者树的结构表示，然后使用深度优先搜索策略进行遍历，遍历的过程中记录和寻找所有可行解或者最优解.

基本思想类同于：

- 图的深度优先搜索
- 二叉树的后序遍历

回溯法按深度优先策略搜索问题的解空间树.  首先从根节点出发搜索解空间树，当算法搜索至解空间树的某一节点时，先利用剪枝函数判断该节点是否可行（即能得到问题的解）. 如果不可行，则跳过对该节点为根的子树的搜索，逐层向其祖先节点回溯；否则，进入该子树，继续按深度优先策略搜索.

回溯法的基本行为是搜索，搜索过程使用剪枝函数来为了避免无效的搜索. 剪枝函数包括两类：1. 使用约束函数，剪去不满足约束条件的路径；2.使用限界函数，剪去不能得到最优解的路径.

问题的关键在于如何定义问题的解空间，转化成树（即解空间树）.解空间树分为两种：子集树和排列树. 两种在算法结构和思路上大体相同.

【例】8 皇后问题. 在有 $8 \times 8$ 个方格的棋盘中放置 8 个皇后，使得任何两个皇后之间不能放互相攻击，即同一行、同一列不能有两个以上的皇后，在与主对角线、副对角线的平行线上也不能有两个以上的皇后，试给出所有的放置方法.

【解】

![](/imgs/algorithm/algorithm-tracking-1.png)

设 $x$ 表示行下标，$y$ 表示列下标，那么我们可以得到约束条件为：对任意两个位置 $(x_i,y_i)$ 和 $(x_j,y_j)$，有
$$
\begin{cases}
x_i \ne x_j \\ \\
y_i \ne y_j \\ \\
|x_i-x_j| \ne |y_i - y_j|
\end{cases}
$$
下面就是定义搜索策略了，然后根据约束条件进行分支限界.

最直接的想法就是从第一个皇后开始摆放，直到第八个皇后摆放完成. 

我们可以规定第一个到第八个皇后分别在第一列到第八列，那么，我们只需要求解合适的行号排列即可.

```java
void queen(int row){
    if(row == 8){
        total++;
    }else{
        for(int col = 0; col != 8; col++){
            c[row]=col;
            if(is_ok(row)){
                queen(row + 1);
            }
        }  
    }
}
```

调用 `queen(0)` 即可，具体到问题只需稍加修改代码就能解决问题.

