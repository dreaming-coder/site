# Linux - Linux 初识

## 1. Linux 的目录结构

![](/imgs/linux/linux-1.png)

- `/bin`

  bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令

- `/boot`

  这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件

- `/dev`

  dev 是 Device(设备) 的缩写，该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的

- `/etc`

  etc 是 Etcetera(等等) 的缩写，这个目录用来存放所有的系统管理所需要的配置文件和子目录

- `/home`

  用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve

- `/lib`

  lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库

- `/lost+found`

  这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件

- `/media`

  Linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下

- `/mnt`

  系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在` /mnt/ `上，然后进入该目录就可以查看光驱里的内容了

- `/opt`

  opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的

- `/proc`

  proc 是 Processes(进程) 的缩写，`/proc` 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息

- `/root`

  该目录为系统管理员，也称作超级权限者的用户主目录

- `/sbin`

  s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序

- `/selinux`

  这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的

- `/srv`

  该目录存放一些服务启动之后需要提取的数据

- `/sys`

  这是Linux 2.6内核的一个很大的变化，暂时不用管

- `/tmp`

  tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的

- `/usr`

  usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录

- `/usr/bin`

  系统用户使用的应用程序

- `/usr/sbin`

  超级用户使用的比较高级的管理程序和系统守护程序

- `/usr/src`

  内核源代码默认的放置目录

- `/var`

  var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件

- `/run`

  是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 `/var/run` 目录，应该让它指向 run

## 2. vim 编辑器

主要了解三种模式的切换，命令可以需要时查找，需要实际使用多了才能记住

- **正常模式**

以 vim 打开一个文档就直接进入一般模式了（这是默认）的模式，你可以使用<kbd>↑</kbd>、<kbd>↓</kbd>、<kbd>←</kbd>、<kbd>→</kbd>按键来移动光标，你可以使用【删除字符】或【删除整行】命令来处理文档内容，也可以使用【复制】和【粘贴】命令来处理你的文件数据

- **插入模式/编辑模式**

按下<kbd>i</kbd>、<kbd>o</kbd>、<kbd>a</kbd>进入编辑模式，一般来说输入<kbd>i</kbd>即可

在这个模式下，程序员可以输入内容

按<kbd>ESC</kbd>键退出到正常模式

- **命令行模式**

在这个模式当中，可以执行相关指令，完成读取、存盘、替换、离开vim、显示行号等动作

按<kbd>ESC</kbd>键退出到正常模式

## 3. 关机与重启

```bash
shutdown -h 10             # 10分钟后关机
shutdown -h 00:00          # 今夜零点关机
shutdown -h now            # 立即关机
shutdown -h 10 "字符串"     # 用于发送给所有登录用户，解释关机原因及安排

# 将 -h 替换为 -r 就表示为重启，其他用法相同

shutdown -c                # 取消关机命令
```

> 还有一些指令也有关机功能（尽量少用）：
>
> - `reboot`：等于`shutdown -r now`
> - `halt`：等于`shutdown -h now`

另外还有个特殊的命令 `sync`，最好再关机重启之前都执行一下这条指令，将内存的数据写入磁盘，防止数据丢失

```bash
sync # 把内存的数据同步到磁盘
```

## 4. 用户管理

### 4.1 新增用户

```bash
useradd 用户名     # 创建新用户
passwd 用户名      # 为新用户指定密码
```

### 4.2 删除用户

```bash
userdel -r 用户名
```

只有一个参数可选 `-r` ；如果加参数 `-r `，表示在删除用户的同时，一并把用户的家目录及本地邮件存储的目录或文件也一同删除

### 4.3 用户注销

注销当前用户，断开当前连接

```bash
logout
```

> 图形运行级别该命令无效

### 4.4 查询用户信息

基本语法：

```bash
id 用户名
```

查看当前用户：

```bash
whoami
```

### 4.5 切换用户

语法：

```bash
su - 用户名
```

> 低权限到高权限用户需要输入密码验证

> 从切换的用户退出到原来的用户可以使用 `exit` 命令

### 4.6 综合示例

![](/imgs/linux/linux-2.png)

## 5. 用户组管理

用户组类似于角色，系统可以对有共性的多个用户进行统一的管理

### 5.1 新增组

```bash
groupadd 组名
```

### 5.2 删除组

```bash
groupdel 组名
```

### 5.3 添加用户时直接加上组

```bash
useradd -g 用户组 用户名
```

### 5.4 修改用户的组

```bash
usermod -g 用户组 用户名
```

注意，`usermod` 命令的参数还有很多：

```bash
usermod [-u uid [-o]] [-g group] [-G group,...]
		[-d 主目录 [-m]] [-s shell] [-c 注释] [-l 新名称]
		[-f 失效日] [-e 过期日] [-p 密码] [-L|-U] 用户名
```

`usermod ` 命令会参照你命令列上指定的部份修改系统帐号档。下列为 `usermod ` 可选用的参数：

- `-c`

  comment

  更新用户帐号 password 档中的注解栏，一般是使用 `chfn(1)` 来修改

- `-d`

  home_dir

  更新用户新的登入目录。如果给定 `-m` 选项，用户旧目录会搬到新的目录去，如旧目录不存在则建个新的

- `-e`

  expire_date

  用户帐号停止日期，日期格式为 `MM/DD/YY`

- `-f`

  inactive_days

  帐号过期几日后永久停权，当值为 0 时帐号则立刻被停权，当值为 -1 时则关闭此功能。预设值为 -1

- `-g`

  initial_group

  更新用户新的起始登入用户组。**用户组名须已存在**。用户组 ID 必须参照既有的的用户组。用户组 ID 预设值为 1

- `-G`

  group, [...]

  定义用户为一堆 groups 的成员。每个用户组使用 `, ` 区格开来，不可以夹杂空白字元。用户组名同 `-g` 选项的限制。如果用户现在的用户组不再此列，则将用户由该用户组中移除

- `-l`

  login_name

  变更用户 login 时的名称为 login_name，其它不变。特别是，用户目录名应该也会跟着更动成新的登入名

- `-s`

  指定新登入 shell。如此栏留白，系统将选用系统预设 shell

- `-u`

  必须为唯一的ID值，除非用  `-o ` 选项。数字不可为负值。预设为最小不得小于 `/etc/login.defs` 中定义的 `UID_MIN` 值。`0` 到 `UID_MIN` 值之间是传统上保留给系统帐号使用。用户目录树下所有的档案目录其 userID 会自动改变。放在用户目录外的档案则要自行手动更动

> [!WARNING]
>
> - `usermod ` 不允许你改变正在线上的用户帐号名称。当 `usermod ` 用来改变 userID，必须确认这名 user 没在电脑上执行任何程序。
>
> - `usermod` 工具和 `useradd` 的参数差不多；两者不同之处在于 `useradd `是添加，`usermod `是修改。

![](/imgs/linux/linux-3.png)

### 5.5 用户和组的相关文件

- **/etc/passwd** 文件

  用户的配置文件，记录用户的各种信息

  每行的含义：`用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录shell`

- **/etc/shadow** 文件

  口令配置文件

  每行的含义：**登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志**

- **/etc/group** 文件

  用户组的配置文件，记录 Linux 包含的组信息

  每行含义：**组名:口令:组标识号:组内用户列表**

## 6. Linux 实用指令

### 6.1 指定运行级别

- `0`：关机
- `1`：单用户（找回丢失密码）
- `2`：多用户无网络服务
- `3`：多用户有网络服务
- `4`：保留
- `5`：图形界面
- `6`：重启

常用的运行级别是 3 和 5，要修改默认的运行级别可修改配置文件，系统的运行级别的配置文件是：`/etc/inittab`

还有切换到指定运行级别的指令：

```bash
init [0123456]
```

**【面试题】如何找回 root 用户密码**

【思路】进入到单用户模式，然后修改 root 密码。因为进入到单用户模式，root 不需要密码就可以登录

- 第一步：在开机时，见到如下界面，输入<kbd>e</kbd> 进入引导设置界面

![](/imgs/linux/linux-4.png)

- 第二步：输入<kbd>e</kbd>进行设置编辑

![](/imgs/linux/linux-5.png)

- 第三步：将光标定位到第二行，输入<kbd>e</kbd> 进行编辑

![](/imgs/linux/linux-6.png)

- 第四步：输入` 1` 表明要进入到单户模式，然后回车，退回到上一步的界面

![](/imgs/linux/linux-7.png)

- 第五步：输入<kbd>b</kbd> 开始引导启动 Linux，此时进入之后的界面如下图所示

![](/imgs/linux/linux-8.png)

- 第六步：输入命令 `passwd root` 进行修改密码，之后输入命令 `init 5` 进入图形界面级别或者 `init 3` 进入多用户有网络服务级别运行

### 6.2 帮助指令

当我们对某个指令不熟悉时，我们可以使用 Linux 提供的帮助指令来了解这个指令的使用方法

- **man**

```bash
man [命令或配置文件]     # 获得帮助信息
```

- **help**

```bash
help 命令              # 获得shell内置命令的帮助信息
```

### 6.3 文件目录类

- **pwd** 指令

  ```bash
  pwd
  ```

  显示当前工作目录的绝对路径

- **ls** 指令

  ```bash
  ls [选项] [目录或是文件]
  ```

  常用选项：

  - `-a`：显示当前目录所有的文件和目录，包括隐藏的
  - `-l`：以列表方式显示信息

- **cd** 指令

  ```bash
  cd [参数]      # 切换到指定目录
  ```

  常用参数：

  - 绝对路径和相对路径
    `cd ~` 或者`cd`：回到自己的家目录
    `cd ..` ：货到当前目录的上一级目录

- **mkdir** 指令

  ```bash
  mkdir [选项] 要创建的目录
  ```

  常用选项：`-p`，用于创建多级目录

  例如：

  - 创建一个目录：`mkdir dog`
  - 创建多级目录：`mkdir -p animal/cat`

- **rmdir** 指令

  ```bash
  rmdir [选项] 要删除的空目录
  ```

  【注意】 该命令删除的是空目录，如目录下有内容时是无法删除的，如果要删除非空目录，需要使用 `rm -rf  要删除的目录`

- **touch** 指令

  ```bash
  touch 文件名称列表
  ```

  创建指定文件名称的空文件，可以是多个文件一起创建

  ```bash
  touch a.txt
  touch b.txt c.txt d.txt
  ```

- **cp** 指令

  ```bash
  cp [选项] src dest
  ```

  将文件拷贝到指定目录

  常用选项：`-r`，递归复制整个文件夹，如：`cp -r 源目录 目标目录`

- **rm** 指令

  ```bash
  rm [选项] 要删除的文件或目录
  ```

  常用选项：

  - `-r`：递归删除整个文件夹
  - `-f`：强制删除不提示

- **mv** 指令

  ```bash
  mv oldNameFile newNameFile        # 重命名
  mv /temp/movefile /targetFolder   # 移动文件
  ```

- **cat** 指令

  ```bash
  cat [选项] 要查看的文件
  ```

  常用选项：`-n`，显示行号，只能浏览，不能修改，通常通过管道指令和 `more` 一起使用，实现分页查看，如：

  ```shell
  cat -n hello.txt | more
  ```

- **more** 指令

  `more` 指令是一个基于VIM编辑器的文本过滤器，它以全屏的方式按页显示文本文件的内容

  ```bash
  more 要查看的文件
  ```
进入 `more` 打开的文件后，可以执行如下操作：
  > - <kbd>Space</kbd>：向下翻『一页』
  > - <kbd>Enter</kbd>：向下翻『一行』
  > - <kbd>Q</kbd>：立刻离开 `more`，不再显示该文件内容
  > - <kbd>Ctrl</kbd>+<kbd>F</kbd>：向下滚动一屏
  > - <kbd>=</kbd>：输出当前行号

- **less** 指令

  与 `more` 类似，但是比它强大很多，支持各种显示终端

  `less` 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载的内容，对于大型文件具有较高的效率

  ```bash
  less 要查看的文件
  ```

  进入 `less` 打开的文件后，可以执行如下操作：

  > - <kbd>Space</kbd>：向下翻『一页』
  > - <kbd>Enter</kbd>：向下翻『一行』
  > - <kbd>PgUp</kbd>：向上翻『一页』
  > - <kbd>PgDn</kbd>：向下翻『一页』
  > - <kbd>/</kbd>+字符串：向下搜索字符串的内容
  >   - <kbd>N</kbd>：向下查找
  >   - <kbd>Shift</kbd>+<kbd>N</kbd>：向上查找
  > - <kbd>?</kbd>+字符串：向下搜索字符串的内容
  >   - <kbd>N</kbd>：向下查找
  >   - <kbd>Shift</kbd>+<kbd>N</kbd>：向上查找
  > - <kbd>Q</kbd>：立刻离开 `less`，不再显示该文件内容
  > - <kbd>=</kbd>：输出当前行号

- **\>** 指令和 **\>\>** 指令

  `>` 表示输出重定向，`>>` 表示追加

  【示例】

  ```bash
  ls -l > a.txt             # 列表的内容写入文件 a.txt 中（覆盖写）
  ls -al >> b.txt           # 列表的内容追加到文件 b.txt 的末尾
  cat 文件1 > 文件2          # 将文件1的内容覆盖到文件2
  echo "内容" >> 文件        # 输入文本到文件末尾
  ```

- **echo** 指令

  ```bash
  echo [选项] 输出内容
  ```

  输出内容到控制台

- **head** 指令

  `head` 用于显示文件的开头部分内容，默认情况下显示前 10 行的内容

  ```bash
  head 文件        # 查看文件前 10 行的内容
  head -n 5 文件   # 查看文件前 5 行的内容
  ```

- **tail** 指令

  `tail` 用于显示文件的尾部部分的内容，默认情况下显示后 10 行的内容

  ```bash
  tail 文件       # 显示文件后 10 行的内容
  tail -n 5 文件  # 显示文件后 5 行的内容
  tail -f 文件    # 实时追踪该文档的所有更新，经常用来截取日志
  ```

- **ln** 指令

  ```bash
  ln [-s] [原文件或目录] [软连接名]            # 给原文件创建一个链接
  ln –snf  [新的源文件或目录]   [软链接文件]    # 修改软链接
  rm –rf   ./软链接名称                      # 删除软链接的名称（正确用法）
  rm –rf   ./软链接名称/                     # 这样就会把软链接以及软链接指向下的内容删除，慎重！
  ```

    > [!ATTENTION]
    >
    > `-s` 是代号（symbolic）的意思。这里有两点要注意：
    >
    > - `ln` 命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化
    > - `ln` 的链接有**软链接**和**硬链接**两种，软链接就是 `ln -s xxx xxx` ,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接`ln xxx xxx`,没有参数 `-s`, 它会在你选定的位置上生成一个和源文件大小相同的文件
    >
    > **无论是软链接还是硬链接，文件都保持同步变化，都不会将原本的档案复制一份，只会占用非常少量的磁碟空间**

  > [!TIP]
  >
  > **【硬链接】**
  >
  > 硬链接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬链接。硬链接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要文件，以防止”误删“的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的链接。**只删除一个链接并不影响索引节点本身和其它的链接，只有当最后一个链接被删除后，文件的数据块及目录的连接才会被释放**。也就是说，文件真正删除的条件是与之相关的所有硬链接文件均被删除。

  > [!TIP]
  >
  > **【软链接】**
  >
  > 软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在软连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。

  > [!NOTE]
  >
  > **【两种链接的区别】**
  >
  > 硬链接文件有两个限制：
  >
  > - **不允许给目录创建硬链接**
  > - **只有在同一文件系统中的文件之间才能创建链接，而且只有超级用户才有建立硬链接权限**
  >
  > 对硬链接文件进行读写和删除操作时候，结果和软链接相同。但如果我们删除硬链接文件的源文件，硬链接文件仍然存在，而且保留了原有的内容。其原因是因为对应的文件的索引节点有一个以上的链接。只删除一个链接并不影响索引节点本身和其它的链接，只有当最后一个链接被删除后，文件的数据块及目录的链接才会被释放。文件才会被真正删除。
  >
  > 软链接没有硬链接以上的两个限制，因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。但是软链接的缺点在于：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。

  【示例】在 `/home` 目录下创建一个软链接 linkToRoot，链接到 `/root` 目录，之后删除该软链接

  - 创建软链接

    ![](/imgs/linux/linux-9.png)

  - 删除软链接

    ![](/imgs/linux/linux-10.png)

- **history** 指令

  ```bash
  history                 # 查看已经执行过的历史命令
  history 10              # 查看最近执行过的 10 条命令
  ```

### 6.4 时间日期类

- **date** 指令

  **【查看日期】**

  ```bash
  date                            # 显示当前时间
  date "+%Y"                      # 显示当前年份（四位数）
  date "+%m"                      # 显示当前月份
  date "+%d"                      # 显示当前是哪一天（两位数）
  date "+%Y-%m-%d %H:%M:%S"       # 显示当前日期和时间
  ```

  **【设置日期】**

  ```bash
  date -s 字符串时间
  
  date -s "2020-10-10 11:11:11"
  ```

- **cal** 指令

  ```bash
  cal                    # 显示当前日历
  cal 2020               # 显示 2020 年的日历，光标没有定位到哪一天
  cal 9 2021             # 显示 2021 年 9 月的日历，光标没有定位到哪一天
  cal 11 11 2050         # 显示 2050 年 11 月的日历，光标定位到 11 日
  ```

### 6.5 搜索查找类

- **find** 指令

  `find` 指令将从指定目录下递归地遍历其各个子目录，将满足条件的文件或是目录显示在终端

  ```bash
  find [搜索范围] [选项]
  ```

  常用的主要是三个选项：

  - `-name`：按照指定的文件名查找文件

    ```bash
    find /home -name hello.txt
    find /home -name *.txt
    ```

    > 按文件名，根据名称查找 /home 目录下的 hello.txt 文件

  - `-user`：查找属于指定用户的所有文件

    ```bash
    find /opt -user ice
    ```

    > 按拥有者，查找 /opt 目录下，用户名为 ice 的文件

  - `-size`：按照指定文件大小查找文件

    ```bash
    find / -size +20
    find / -size -40M
    find / -size 30k
    ```

    > 查找整个 Linux 系统下大于20 M 的文件（+n 大于，-n 小于，n 等于）

- **locate** 指令

  `locate` 指令可以快速定位文件路径。`locate` 指令利用实现建立的系统中所有文件名称及路径的 locate 数据库实现快速定位给定的文件。`locate` 指令无需遍历整个系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新 locate 时刻。

  ```bash
  locate 搜索文件
  ```

  > 由于 `locate` 指令基于数据库进行查询，所以第一次运行前，必须使用 `updatedb` 指令创建 locate 数据库

- **grep** 指令 和管道符号 **|**

  grep 是 global regular expression pattern 的缩写，用于过滤查找

  管道符 `|` 表示将前一个命令的处理结果传递给后面的命令处理

  ```bash
  grep [选项] 查找内容 源文件
  ```

  常用选项：

  - `-n` ：显示匹配及行号
  - `-i`：忽略字母的大小写

### 6.6 压缩和解压类

- **gzip** 和 **gunzip** 指令

  `gzip` 用于压缩和 `gunzip` 用于解压缩，压缩文件只能压缩成 `*.gz` 文件

  ```bash
  gzip 文件
  gunzip 文件.gz
  ```

- **zip** 和 **unzip** 指令

  `zip` 用于压缩文件，`unzip` 用于解压文件，这个在项目打包发布中很有用

  ```bash
  zip [选项] XXX.zip 要被压缩的内容     # 压缩文件和目录
  unzip [选项] XXX.zip                # 解压缩
  ```

  `zip` 常用选项：`-r`，递归压缩，即压缩目录

  `unzip` 常用选项：`-d<目录>`，指定解压后文件的存放目录

- **tar** 指令

  `tar` 指令是打包指令，最后打包的文件是 `.tar.gz` 的文件

  ```bash
  tar [选项] XXX.tar.gz 打包的内容
  ```

  常用选项：

  - `-c` ：产生 `.tar `打包文件
  - `-v`：显示详细信息
  - `-f`：指定压缩后的文件名
  - `-z`：打包同时压缩
  - `-x`：解压 `.tar` 文件

  【示例】

  1. 压缩多个文件

     ```bash
     tar -zcvf a.tar.gz a1.txt a2.txt
     ```

  2. 将 /home 文件夹压缩成 myhome.tar.gz

     ```bash
     tar -zcvf myhome.tat.gz /home/      # 压缩中带 home 文件夹
     tar -zcvf myhome.tat.gz -C /home/   # 压缩中仅有 home 下的文件和目录
     ```

  3. 将 a.tar.gz 解压到当前目录

     ```bash
     tar -zxvf a.tar.gz
     ```

  4. 将 myhome.tar.gz 解压到 /opt/tmp 目录下

     ```bash
     tar -zxvf myhome.tar.gz -C /opt/tmp
     ```

     > 目标目录必须存在才能解压成功

## 7. Linux 组管理和权限管理

### 7.1 修改文件用户和用户组

在 Linux 中的每个用户必须属于一个组，不能独立于组外。在 Linux 中每个文件有所有者、所在组、其它组的概念

- 修改文件的所有者

  ```bash
  chown 用户名 文件目录名
  chown -R 用户名 目录名      # 递归修改目录下所有文件和目录的用户
  ```

- 修改文件所在组

  ```bash
  chgrp 组名 文件目录名
  chgrp -R 组名 目录名      # 递归修改目录下所有目录和文件的组
  ```

### 7.2 文件权限

![](/imgs/linux/linux-11.png)

执行 `ls -l` 命令时，每一行记录最开始的一部分代表的就是该文件的权限内容，总共 10 位字符，除去第一位字符，后面 9 位字符每 3 个为一组，分别是拥有者、所在组、其他组的权限

- 第 0 位确定文件类型
  - d：目录
  - -：普通文件
  - l：软链接
  - c：字符设备（键盘，鼠标）
  - b：块文件（硬盘）
- 第 1-3 位确定所有者拥有的该文件的权限
- 第 4-6 位确定所属组拥有的该文件的权限
- 第 7-9 位确定其他用户拥有的该文件的权限

> **rwx 作用到文件**：
>
> `r`：表示可读，`w`：表示可写，`-`：表示没有权限，`x`：表示可执行
>
> **rwx 作用到目录**：
>
> `r`：表示可读，`w`：表示可修改，`-`：表示没有权限，`x`：表示可以进入该目录
>
> 【注】**如果想删除一个文件不仅仅对该文件要有写的权限，而且要对该文件所在目录有修改的权限**

### 7.3 修改权限

通过 `chmod` 指令，可以修改文件或目录的权限

- 第一种方式：+、-、= 变更权限

  u：所有者，g：所有组，o：其他人，a：所有人（u、g、o 的总和）

  - `chmod u=rwx,g=rx,o=x 文件目录名`
  - `chmod o+w 文件目录名`
  - `chmod a-x 文件目录名`

- 第二种方式：通过数字变更权限

  r=4，w=2，x=1，rwx=4+2+1=7

  `chmod u=rwxmg=rx,o=x 文件目录名`相当于`chmod 751 文件名`

## 8. 定时任务调用

任务调度是指系统在某个时间执行的特定的命令或持续

任务调度分为两种

- 系统工作，有些重要的工作必须周而复始地执行。如病毒扫描等
- 个别用户工作，比如对 MySQL 数据库的备份

```bash
crontab [选项]
```

常用选项：

- `-e`：编辑 crontab 定时任务
- `-l`：查询 crontab 任务
- `-r`：删除当前用户所有的 crontab 任务

设定任务的一般步骤：

1. 执行 `crondtab -e` 进入配置文件编辑模式
2. 设置定时任务，一般是 任务设定时间 + 要执行的命令
3. 保存退出

任务设定时间语法如下：

```bash
[秒] [分] [小时] [日] [月] [周] [年]    # 其中年是可选的
```

```
*    *    *    *    *
-    -    -    -    -
|    |    |    |    |
|    |    |    |    +----- 星期中星期几 (0 - 7) (星期天 为0)
|    |    |    +---------- 月份 (1 - 12) 
|    |    +--------------- 一个月中的第几天 (1 - 31)
|    +-------------------- 小时 (0 - 23)
+------------------------- 分钟 (0 - 59)
```

通配符说明：

- `*` 表示所有值。 例如:在分的字段上设置  `*`，表示每一分钟都会触发

- `?` 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如：要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为”`?`” 具体设置为 `0 0 0 10 * ?`

- `-` 表示区间。例如：在小时上设置 “`10-12`”,表示 10,11,12点都会触发

- `,` 表示指定多个值，例如在周字段上设置 “`MON,WED,FRI`” 表示周一，周三和周五触发

- `x/y` 表达一个等步长序列，x为起始值，y为增量步长值。如在分钟字段中使用 `0/15`，则表示为0,15,30和45秒，而 `5/15` 在分钟字段中表示5,20,35,50，你也可以使用 `*/y`，它等同于0/y

- `L`：该字符只在日期和星期字段中使用，代表“Last”的意思，但它在两个字段中意思不同。`L`在日期字段中，表示这个月份的最后一天，如一月的31号，非闰年二月的28号；如果`L`用在星期中，则表示星期六，等同于7。但是，如果`L`出现在星期字段里，而且在前面有一个数值 X，则表示“这个月的最后X天”，例如，`6L` 表示该月的最后星期五

- `W`:该字符只能出现在日期字段里，是对前导日期的修饰，表示离该日期最近的工作日。例如`15W`表示离该月15号最近的工作日，如果该月15号是星期六，则匹配14号星期五；如果15日是星期日，则匹配16号星期一；如果15号是星期二，那结果就是15号星期二。但必须注意**关联的匹配日期不能够跨月，如你指定 `1W`，如果1号是星期六，结果匹配的是3号星期一，而非上个月最后的那天**。**`W`字符串只能指定单一日期，而不能指定日期范围**

  `LW`组合：在日期字段可以组合使用`LW`，它的意思是当月的最后一个工作日；

- `#`：该字符只能在星期字段中使用，表示当月某个工作日。如`6#3`表示当月的第三个星期五(6表示星期五，#3表示当前的第三个)，而4#5表示当月的第五个星期三，假设当月没有第五个星期三，忽略不触发

- `C`：该字符只在日期和星期字段中使用，代表“Calendar”的意思。它的意思是计划所关联的日期，如果日期没有被关联，则相当于日历中所有日期。例如`5C`在日期字段中就相当于日历5日以后的第一天。`1C`在星期字段中相当于星期日后的第一天

**【任务调度的简单实例】每隔 1 分钟，将当前的日期信息，追加到 `/home/mydate` 文件中**

1. 先编写一个文件  mytask1.sh

    写入`date >> /tmp/mydate`

2. 给 mytask1.sh 一个可执行权限

   前面才写过得权限修改语句  `chmod` 语句

3. 执行 `crontab -e`
   写入 `*/1 * * * * /home/mytask1.sh` 

4. 保存退出

**crond** 相关指令：

- `crontab -r`：终止任务调度
- `crontab -l`：列出当前有哪些任务调度
- `service crond restart`：重启任务调度

## 9. Linux 分区

### 9.1 分区基础知识

- MBR 分区
  - 最多支持四个主分区
  - 系统只能安装在主分区
  - 扩展分区要占一个主分区
  - MBR 最大只支持2 TB，但拥有最好的兼容性
- GTP 分区
  - 支持无线多个主分区（但是操作系统可能有限制，比如 Windows 下最多 128 个分区）
  - 最大支持 18 EB 的大容量（1 EB = 1024 PB, 1 PB = 1024 TB）
  - Windows 7 64 位以后支持GTP

### 9.2 Linux 分区

- Linux 来说无论有几个分区，分给哪一目录使用，它归根到底就只有一个根目录，一个独立且唯一的文件结构，Linux 中每个分区都是用来组成这个文件系统的一部分
- Linux 采用了一种叫 “载入” 的处理办法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得

## 10. Linux进程管理

### 10.1 基本介绍

- 在 Linux 中，每个执行的程序都称为一个进程，每一个进程都分配一个 ID 号
- 每一个进程都会对应一个父进程，而这个父进程可以复制多个子进程
- 每个进程都可能以两种方式存在，前台与后台。所谓前台进程就是用户目前的屏幕上可以进行操作的；后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式进行
- 一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才结束

### 10.2 进程相关操作

`ps` 命令是用来查看目前系统中有哪些正在执行，以及它们执行的状况，可以不加任何参数

```bash
ps -a         # 显示当前终端的所有进程信息
ps -u         # 以用户的格式显示进程信息
ps -x         # 显示后台进程运行的参数
```

如果先显示父进程，可以使用命令

```bash
ps -ef
```

若是某个进程执行一半需要停止时，或是已很大的系统资源时，此时可以考虑停止该进程，可以使用 `kill` 命令完成此操作

```bash
kill [选项] 进程号     # 通过进程号杀死进程
killall 进程名称      # 通过进程名称杀死进程，也支持通配符
```

常用选项是 `-9`，表示强迫进程立即停止

查看进程树，可以使用 `pstree` 命令

```bash
pstree [选项]
```

常用选项：`-p`，显示进程的 PID，`-u`，显示进程所属用户

### 10.3 服务管理

服务本质就是进程，但是是运行太后台的，通常都会监听某个端口，等待其他进程的请求，比如 MySQL，因此我们又称为守护进程。

service 管理有如下常见的指令：

```bash
service 服务名 start|stop|restart|reload|status
systemctl  # CentOS 7.0 之后，不再使用 service，而是 systemctl
```

### 10.4 chkconfig 指令

通过 `chkconfig` 指令可以给每个服务的各个运行级别设置自动启动/关闭

```bash
chkconfig --list                           # 查看服务
chkconfig 服务名 --list                     # 查看指定服务
chkconfig --level 运行级别 服务名 on/off     # 修改指定服务在某个运行级别下是否自动启动
```

### 10.5 进程监控

#### 10.5.1 动态进程监控

`top` 命令和 `ps` 命令很相似，它们都用来显示正在执行额进程。`top` 与 `ps` 最大的不同之处，在于 `top` 在执行一段时间可以更新正在运行的进程

```bash
top [选项]
```

- `-d 秒数`：指定 `top` 命令每隔几秒更新，默认是 3 秒在 `top` 命令的交互模式当中可以执行的命令
- `-i`：使 `top` 不显示任何闲置或僵死进程
- `-p`：通过指定监控进程 ID 来仅仅监控某个进程的状态

在 `top` 命令的结果中还可以执行交互命令：

- `P`：按 CPU 使用率排序，默认排序字段
- `M`：按内存使用率排序
- `N`：按 PID 排序
- `q`：退出 `top`

#### 10.5.2 网络状态监控

```bash
netstat [选项]
netstat -anp     # 一般都这么写
```

- `-an`：按一定顺序排列输出
- `-p`：显示哪个进程在调用

另外，测试网络连接性可以用 `ping` 命令，和 Windows 中的 DOS 命令一样。





